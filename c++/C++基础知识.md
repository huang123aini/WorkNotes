
## class & struct

### 不同点：
1. struct 成员变量和基类的成员变量 (包括成员函数) 默认都是 public
2. class  成员变量和基类的成员变量 (包括成员函数) 默认都是 private

### 相同点：
1. class 和 struct都可以使用 public & protected & private 修饰 成员变量和成员函数
2. 都可以使用继承

### 建议：
1. 对于plain-old-data(POD)类型的数据或者类型使用 struct. 即没有任何类特征的数据.
2. 当使用私有或受保护成员、非默认构造函数和运算符等功能时，请使用类。
   

### POD(Plain Old Data)
1. 即没有构造函数、析构函数和虚成员函数的类：C++中的普通旧数据结构是一个聚合类，仅仅包含PODs作为成员，没有用户定义的析构函数，复制赋值运算符，也没有指向成员类型的非静态成员。
2. POD是一种类型(包括类)，c++编译器保证结构中不会发生任何"魔法"，也就是说一个POD,被C++编译器编译后行为就是固定的了，不依赖运行时。(没有vtable & 重载)



### 在c++中，一个类有八个默认函数:
1. 默认构造函数
2. 默认拷贝构造函数
3. 默认析构函数
4. 默认重载赋值运算符函数
5. 默认重载取址运算符函数
6. 默认重载取址运算符const函数
7. 默认移动构造函数(c++11)
8. 默认重载移动赋值操作符函数(c++11)
<font color=#008000>所有这些函数都是inline & public的</font>

class A{
  public: 
    //默认构造函数
    A();

    //默认拷贝构造函数
    A(const A&);

    //默认析构函数
    ~A();

    //默认重载赋值运算符函数
    A& operator = (const A&);

    //默认重载取址运算符函数
    A* operator& ();

    //默认重载取址运算符const函数
    const A* operator & () const;

    //默认移动构造函数
    A(A&&);

    //默认重载移动赋值操作符
    A& operator = (const A&&);    
};


## c++的类对象创建过程
  c++在创建类对象的时候需要经过两个阶段: 分配空间(Allocation) & 初始化(Initialization)

### 分配空间
1. 创建C++类对象的第一步就是为其分配内存空间。对于全局对象、静态对象以及分配在栈区域内的对象，对它们的内存分配发生在编译阶段.
2. 对于分配在堆区域内的对象，他们的分配是在运行时动态进行的
3. 内存空间的分配过程涉及到两个关键的问题：
   1. 需要分配空间的大小.
   2. 是否有足够的内存空间来满足分配.

### 初始化
1. 两个概念: 初始化(Initialization) 和赋值(Assignment)
2. 初始化早于赋值，它是随着对象的诞生一起进行的.
3. 赋值是在对象诞生以后又给它赋一个新值.
4. 在c++中，提供了类成员的初始化列表，并且初始化列表是先于构造函数体内的代码执行.

### 初始化列表
1. 因为初始化列表中无法直接初始化基类的数据成员，所以需要在列表中指定基类的构造函数，如果不指定，编译器则会调用基类的默认构造函数
2. 推荐使用初始化列表，它会比在函数体内初始化派生类成员更快，这是因为在分配内存后，在函数体内又多进行了一次赋值操作。
3. 初始化列表并不能指定初始化的顺序，正确的顺序是，首先初始化基类，其次根据派生类成员声明次序依次初始化

### 只能使用初始化列表(initialization list) 而不能使用赋值(assignment)
* 需要初始化的数据成员是对象的情况(包含继承情况下: 通过显示调用父类的构造函数对父类数据成员进行初始化) 
* 需要初始化const修饰的类成员
* 需要初始化引用成员数据
* 子类初始化父类的私有成员，需要在(并且只能在)参数初始化列表中显示调用父类的构造函数.

**类对象是默认使用初始化列表的，当没有无参构造函数时，就必须显示使用初始化列表(所以不论如何，都会使用到初始化列表)**

**当类成员中含有一个const对象 或者一个引用时，必须经过成员初始化列表进行初始化，因为const对象或者引用在声明的同时就必须初始化，而在构造函数中，做的是对它们的赋值，并不是初始化**

### 初始化列表的顺序
构造函数需要初始化的数据成员，不论是否显示的出现在构造函数的成员初始化列表中，都会在该处完成初始化。 **并且初始化的顺序和变量声明时的顺序是一致的，与列表中的先后顺序无关**




## c++ 关键字
1. new & delete: 
2. this
3. default:  被标识的默认函数将使用类的默认行为，如： A() = default;
4. delete:   被标识的默认函数将禁用， 如A() = delete;
5. 
5. override: 被标识的函数需要强制重写基类虚函数;
6. final:    被标识的函数禁止重写基类虚函数;
7. const & constexpr



### new & delete & malloc & free

区别1:
* new/delete:   这两个是C++关键字，需要编译器支持
* malloc/free:  这俩是库函数，若要使用则需要引入相应的头文件才可以正常使用

区别2：
* malloc: 申请内存需要显示填入申请内存的大小
* new: 无需显示填入申请的内存大小，new会根据new的类型分配内存

区别3：内存位置
* new:    此操作符分配的内存空间是在自由存储区
* malloc: 申请的内存是在堆空间

区别4： 返回类型的区别
* new: new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，
无需进行类型转换，故new是符合类型安全性的操作符。
* malloc: malloc内存分配成功则是返回void*，需要通过强制类型转换将void*指针转换为我们需要的类型。

区别5: 分配失败情况
* malloc: 分配失败时返回NULL,我们可以通过判断返回值可以得知是否分配成功
* new分配失败时会抛出bad_alloc异常，不会返回NULL,分配失败时如果不捕获异常，则程序会异常退出

区别6: 定义对象系统调度过程
* new: 使用new操作符来分配对象内存时经历三个步骤
  1. 调用operator new函数（对于数组是 operator[]）分配一块足够的内存空间(通常底层默认使用malloc实现，除非程序员重载new操作符)
  以便存储特定类型的对象。
  2. 编译器运行相应的构造函数以构造对象，并为其传入初值
  3. 对象构造完成后，返回一个指向该对象的指针
* delete: 使用delete操作符来释放对象内存时会经历两个步骤
  1. 调用对象的析构函数
  2. 编译器调用 operator delete(或 operator delete[])函数释放内存空间(通常底层默认使用free实现，除非程序员重载delete操作符)  

区别7: 内存大小扩张
  * malloc: 使用malloc分配内存后，发现内存不够用，可以通过realloc函数来扩张内存大小，
  realloc会先判断当前申请的内存后边是否有足够的内存进行扩张，如果有足够的空间，那么就会往后边继续申请空间，并返回原来的指针。
  否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间的内容拷贝到新的内存空间里，最后返回新的地址指针。
  * new: new没有内存扩张机制。


### this指针

1. this指针是一个隐含于每一个非静态成员函数中的特殊指针，**指向调用该成员函数的那个对象**
2. 当一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，**然后调用成员函数，每次成员函数存取数据成员时都隐式使用this指针**
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. this 指针被隐含地声明为：**ClassName *const this,** 意味着不能给this指针赋值;
5. 在ClassName类的const成员函数中，this指针类型为: const ClassName* const,说明不能对this指针指向的const成员修改
6. this并不是一个常规变量，而是一个右值，所以不能取this的地址(即:不能&this)
7. 在以下场景中经常需要显示使用this指针
   * 为实现对象的链式引用
   * 为避免对同一对象进行赋值操作
   * 在实现一些数据结构时，如list


### const vs constexpr

**简单来说const其实是readonly, constexpr才是const**
对于修饰的Object来说，const并未区分出编译期常量和运行期常量. constexpr限定在了编译期常量
**Note:constexpr修饰的函数，返回值不一定是编译期常量**

//const & constexpr
#include <array>
constexpr int foo(int i) {
    return i + 5;
}
int main(int argc, char* argv[]) {
  int i = 10;
  std::array<int,foo(5)> arr; //OK
  std::cout << "constexpr foo function is compare success." << std::endl;
  
  foo(i); //普通调用 OK
  std::array<int, foo(i)> arr1; //Error
}

